# Financial Document Analyzer - Project Intelligence

## Project Overview

This is a full-stack financial document analyzer built with FastAPI (Python) backend and React (TypeScript) frontend. The system processes financial documents (invoices, receipts, statements, contracts) and extracts structured data using AI/ML capabilities.

## Current Status

- **Phase**: Database setup and core integration
- **Branch**: `feat/db-setup`
- **Completion**: ~30% (infrastructure complete, core features pending)
- **Key Issue**: All endpoints return mock data, no database integration yet

## Architecture Patterns

### Backend (FastAPI)

- **Router Pattern**: Each domain (health, documents, analytics) has its own router
- **Pydantic Models**: All request/response validation using Pydantic schemas
- **Middleware Stack**: CORS, logging, exception handling, trusted hosts
- **Error Handling**: Centralized exception handlers with consistent error responses
- **Configuration**: Pydantic Settings for environment-based configuration

### Frontend (React + TypeScript)

- **Component Architecture**: Radix UI components with Tailwind CSS
- **Type Safety**: Strong TypeScript typing throughout
- **Build System**: Vite for fast development and building
- **State Management**: React hooks (no external state management yet)
- **React Version**: React 19 with latest best practices
- **Modern Patterns**: Functional components, hooks, context API

## Key Implementation Details

### API Endpoints

- `GET /` - API information
- `GET /health` - Health check with system status
- `GET /documents/` - List documents (currently mock data)
- `POST /documents/upload` - Upload with file validation (10MB limit, specific file types)
- `GET /documents/{id}` - Get document details (currently mock data)
- `DELETE /documents/{id}` - Delete documents (currently mock data)

### Data Models

- **DocumentType**: Enum (invoice, receipt, statement, contract, other)
- **DocumentUploadRequest**: Upload request with metadata
- **DocumentAnalysisResponse**: Analysis results with confidence score
- **ErrorResponse**: Standardized error format with timestamp

### File Handling

- **Supported Types**: PDF, PNG, JPG, JPEG, TIFF
- **Size Limit**: 10MB per document
- **Validation**: File type and size validation implemented
- **Processing**: Upload handling complete, analysis engine pending

## Development Workflow

### Backend Development

```bash
cd backend
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
uvicorn app.main:app --reload
```

**CRITICAL**: During development, never run the backend detached (with &, nohup, or in background). Always run in foreground so it stops when terminal closes or Ctrl+C is pressed. In production, detached processes are acceptable.

### Frontend Development

```bash
cd frontend
pnpm install
pnpm dev
```

### Ports

- Backend: http://localhost:8000
- Frontend: http://localhost:5173
- API Docs: http://localhost:8000/docs (when debug=True)

## Critical Next Steps

### Immediate Priorities

1. **Database Integration**: Set up PostgreSQL with SQLAlchemy models
2. **Document Processing**: Integrate OCR library (Tesseract/PaddleOCR)
3. **Frontend Integration**: Connect React to real API endpoints
4. **Testing**: Add comprehensive test suite

### Technical Decisions Needed

- **Database**: PostgreSQL for production, SQLite for development
- **OCR Engine**: Tesseract vs PaddleOCR vs cloud-based solutions
- **Document Processing**: Sync vs async processing for large files
- **Authentication**: JWT implementation strategy

## Code Quality Standards

### Backend

- Use Pydantic for all data validation
- Implement proper error handling with HTTP status codes
- Add comprehensive logging for debugging
- Follow FastAPI best practices for async operations

### Frontend

- Use TypeScript for all components and functions
- Implement proper error boundaries
- Use Radix UI for accessible components
- Follow React hooks patterns for state management
- **React 19 Compliance**: Follow latest React documentation patterns
- **Component Patterns**: Use functional components, avoid React.FC
- **Import Patterns**: Use named imports, avoid default React import
- **Hook Rules**: Follow rules of hooks (only at top level, only in React functions)
- **Context Patterns**: Use createContext with proper TypeScript typing
- **Performance**: Use useMemo, useCallback for expensive operations

## Common Patterns

### Error Handling

- Backend: Use HTTPException with proper status codes
- Frontend: Implement error boundaries and user feedback
- Logging: Use structured logging with timestamps

### Data Validation

- Backend: Pydantic models with field validation
- Frontend: Form validation with React Hook Form + Zod
- File Upload: Validate type, size, and content

### API Design

- RESTful endpoints with proper HTTP methods
- Consistent response format (SuccessResponse, ErrorResponse)
- Proper status codes and error messages
- Request/response logging for debugging

## Known Issues & Solutions

### Current Issues

1. **Mock Data**: All endpoints return mock data - need database integration
2. **File Processing**: Upload works but no analysis - need OCR integration
3. **Frontend Integration**: No API calls - need service layer
4. **Testing**: No tests - need comprehensive test suite

### Solutions

1. Implement SQLAlchemy models and database operations
2. Integrate OCR library and create analysis pipeline
3. Create API service layer in frontend
4. Add pytest for backend, Jest for frontend

## React 19 Best Practices & Compliance

### Component Patterns

1. **Functional Components Only**

   ```tsx
   // ✅ Good - Modern functional component
   const MyComponent = ({ children }: Props) => {
     return <div>{children}</div>;
   };

   // ❌ Avoid - React.FC is discouraged
   const MyComponent: React.FC<Props> = ({ children }) => {
     return <div>{children}</div>;
   };
   ```

2. **Import Patterns**

   ```tsx
   // ✅ Good - Named imports only
   import { useState, useEffect } from "react";
   import type { ReactNode } from "react";

   // ❌ Avoid - Default React import (unnecessary in React 17+)
   import React, { useState, useEffect } from "react";
   ```

3. **Hook Usage**

   ```tsx
   // ✅ Good - Hooks at top level
   const MyComponent = () => {
     const [state, setState] = useState(initialValue);
     const { data, isLoading } = useQuery();

     useEffect(() => {
       // side effects
     }, []);

     return <div>Content</div>;
   };
   ```

4. **Context Patterns**

   ```tsx
   // ✅ Good - Proper context with TypeScript
   interface ContextType {
     value: string;
     setValue: (value: string) => void;
   }

   const MyContext = createContext<ContextType | undefined>(undefined);

   export const MyProvider = ({ children }: { children: ReactNode }) => {
     const [value, setValue] = useState("");
     return (
       <MyContext.Provider value={{ value, setValue }}>
         {children}
       </MyContext.Provider>
     );
   };
   ```

5. **Custom Hooks**
   ```tsx
   // ✅ Good - Custom hook with proper error handling
   export const useAuth = () => {
     const context = useContext(AuthContext);
     if (context === undefined) {
       throw new Error("useAuth must be used within an AuthProvider");
     }
     return context;
   };
   ```

### Performance Optimization

1. **Memoization**

   ```tsx
   // ✅ Use useMemo for expensive calculations
   const expensiveValue = useMemo(() => {
     return heavyCalculation(data);
   }, [data]);

   // ✅ Use useCallback for stable function references
   const handleClick = useCallback(() => {
     doSomething();
   }, [dependency]);
   ```

2. **Component Optimization**
   ```tsx
   // ✅ Memo for preventing unnecessary re-renders
   const ExpensiveComponent = memo(({ data }: Props) => {
     return <div>{data}</div>;
   });
   ```

### Error Handling

1. **Error Boundaries**

   ```tsx
   // ✅ Error boundary for catching component errors
   class ErrorBoundary extends Component<Props, State> {
     constructor(props: Props) {
       super(props);
       this.state = { hasError: false };
     }

     static getDerivedStateFromError(error: Error): State {
       return { hasError: true };
     }

     componentDidCatch(error: Error, errorInfo: ErrorInfo) {
       console.error("Error caught by boundary:", error, errorInfo);
     }

     render() {
       if (this.state.hasError) {
         return <h1>Something went wrong.</h1>;
       }
       return this.props.children;
     }
   }
   ```

2. **Async Error Handling**
   ```tsx
   // ✅ Proper async error handling in effects
   useEffect(() => {
     const fetchData = async () => {
       try {
         const result = await api.getData();
         setData(result);
       } catch (error) {
         setError(error instanceof Error ? error.message : "Unknown error");
       }
     };

     fetchData();
   }, []);
   ```

### TypeScript Integration

1. **Component Props**

   ```tsx
   // ✅ Proper TypeScript interfaces
   interface ButtonProps {
     children: ReactNode;
     onClick?: () => void;
     variant?: "primary" | "secondary";
     disabled?: boolean;
   }

   const Button = ({
     children,
     onClick,
     variant = "primary",
     disabled,
   }: ButtonProps) => {
     return (
       <button onClick={onClick} disabled={disabled}>
         {children}
       </button>
     );
   };
   ```

2. **Event Handlers**

   ```tsx
   // ✅ Proper event typing
   const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
     setValue(event.target.value);
   };

   const handleSubmit = (event: FormEvent<HTMLFormElement>) => {
     event.preventDefault();
     // handle submit
   };
   ```

## Development Notes

- Always check memory bank files for current context
- Update progress.md after significant changes
- Follow the established patterns for consistency
- Test thoroughly before marking tasks complete
- Document any new patterns or decisions in .cursorrules
- **React Compliance**: Ensure all components follow React 19 best practices
- **Code Review**: Check for React.FC usage, unnecessary React imports, hook violations
